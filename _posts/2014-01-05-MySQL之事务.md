---
layout: post
title: "MySQL之事务"
date: 2014-01-5 17:17:21
categories: DB MySQL
tags: MySQL 事务
updateTime: 2021-09-09
---

* content
{:toc}
### 1 [InnoDB 架构](https://dev.mysql.com/doc/refman/8.0/en/innodb-architecture.html)

![2021-09-09_innodb-architecture](\image\db\innodb-architecture.png)

[图片来自官网](https://dev.mysql.com/doc/refman/8.0/en/innodb-architecture.html)

### 2 [数据库事务](https://baike.baidu.com/item/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1/9744607?fr=aladdin)

> 数据库事务( transaction)是访问并可能操作各种[数据项](https://baike.baidu.com/item/数据项/3227309)的一个数据库操作[序列](https://baike.baidu.com/item/序列/1302588)，这些操作要么全部执行,要么全部不执行，是一个不可分割的工作单位。事务由事务开始与事务结束之间执行的全部数据库操作组成。（来自百度）

#### 2.1 如何实现事务

> 实现事务采取了哪些技术以及思想？ACID: atomicity 、consistency 、isolation、durability
>
> 原子性使用 undo log ，从而达到回滚；持久性：用 redo log，从而达到故障后恢复；隔离性使用锁以及MVCC,运用的优化思想有读写分离，读读并行，读写并行；一致性：通过回滚，以及恢复，和在并发环境下的隔离做到一致性。



#### 2.2 事务的隔离级别

> 默认是可重复读

| 事务隔离级别                                     | 脏读   | 不可重复读 | 幻读                                                         |
| ------------------------------------------------ | ------ | ---------- | ------------------------------------------------------------ |
| 未提交读（Read uncommitted)                      | 可能   | 可能       | 可能                                                         |
| 已提交读（Read committed)                        | 不可能 | 可能       | 可能                                                         |
| 可重复读（Repeatable Read) <br/>innodb 默认（RR) | 不可能 | 不可能     | <font color='red'>innodb不可能<br/>采用临键锁: 半开半闭 （1,10] (10,+∞)</font> |
| 串行化（Serializable)                            | 不可能 | 不可能     | 不可能                                                       |

> 为甚大厂把RR改为RC?
>
> ### 提高并发
>
> **在 RC 中，只会对索引增加Record Lock，不会添加Gap Lock和Next-Key Lock。**
>
> **RC只支持row格式的binlog**
>
> ****
>
> **在 RR 中，为了解决幻读的问题，在支持Record Lock的同时，还支持Gap Lock和Next-Key Lock；**
>
> **RR 的隔离级别同时支持statement、row以及mixed三种。**

[MySQL 默认隔离级别是RR，为什么阿里等大厂会改成RC？](https://mp.weixin.qq.com/s/JGqx4gjTxuGPojjbgnW_sQ)

#### 2.3 如何实现读一致性问题？

> 基于MVCC控制：多版本并发控制

- 脏读：事务A读取到了事务B<font color='red'>更新后且没有提交</font>的数据。===> <font color='red'>事务B有可能会回滚</font>

  ![2021-11-13_MySQL脏读](\image\db\2021-11-13_MySQL脏读.png)

- 不可重复读：事务A读取到了事务B<font color='red'>更新/删除后且提交</font>的数据。

  ![2021-11-13_MySQL不可重复读](\image\db\2021-11-13_MySQL不可重复读.png)

- 幻读：事务A读取到了事务B<font color='red'>插入后且提交</font>的数据。

- ![2021-11-13_MySQL幻读](\image\db\2021-11-13_MySQL幻读.png)

=》我们仍能查询事务之前的数据，当某一条数据修改或删除之后。

`快照`

#### 2.4 锁

> 锁的颗粒度：行锁、表锁

##### 2.4.1 行锁-共享锁（Shared Locks）

```sql
--  给一行加读锁
select  * from tableName lock in share mode;//行锁，事务完成后自动释放掉
```

##### 2.4.2 行锁 - 排它锁（Exclusive Locks）

```sql
-- 1. mysql 增删改时自动添加一个排它锁
-- 2. 基于一行数据时，使用 for update

select * from user where id = 1 for update;//BLOCKED

```

##### 2.4.3 意向锁

> 数据库自己维护的



#### 2.5 锁的算法



#### 参考

[深入浅出数据库索引原理](https://zhuanlan.zhihu.com/p/23624390)

[MySQL的索引原理（图解）](https://www.cnblogs.com/bigox/p/11703328.html)

[InnoDB参数设置](https://dev.mysql.com/doc/refman/8.0/en/innodb-parameters.html)

```mysql
-- 发展的眼光、对比看待 
```

