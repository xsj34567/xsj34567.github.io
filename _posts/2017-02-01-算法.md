---
layout: post
title: "算法"
date: 2017-02-01
categories: 算法
tags: 算法
author: mzz
updateTime: 2019-10-14
---

* content
{:toc}

## 目的

```
程序 = 数据结构 + 算法
```

了解数据结构、算法思想、优缺点、合理运用到项目中，
常见算法：

## 一、算法

### 1.[二分法查找]([https://baike.baidu.com/item/%E4%BA%8C%E5%88%86%E6%B3%95%E6%9F%A5%E6%89%BE/9751511?fr=aladdin#3](https://baike.baidu.com/item/二分法查找/9751511?fr=aladdin#3))

 有序的数组，效率 O(logn)

实例： 猜数字 100 ，需要猜多少次 （log128)

对数与幂运算互为逆运算。（幂运算表示指数个底数相乘）

#### 1.1 常用有序数据查找

```java
    public class BinaryTest
    {
        public static int binary(int[] array, int value)
        {
            if(array == null || array.length ==0)
            {
                return -1;
            }
            int start = 0;
            int end = array.length - 1;
            int middle;
            while(start+1 < end)
            {
				middle = start+(end - start) / 2;
                if(value == array[middle])
                {
                    return middle;
                }
                if(value > array[middle])
                {
                    start = middle;
                }
                if(value < array[middle])
                {
                    end = middle;
                }
            }
            if(value==array[start])
            {
                return start;
            }
            if(value==array[end])
            {
                return end;
            }
            return -1;
        }
        public static void main(String[] args)
        {
            int[] a = {1, 2, 3, 4, 5, 6, 7, 8, 9};
            int value = binary(a, 9);
            System.out.println(value);
        }
    }
```

#### 1.2 旋转有序数组排序 （无重复数组）

```java
//数学： 2、4象限   通用
 public class BinaryTest
    {
        public static int binary(int[] array, int value)
        {
            if(array == null || array.length ==0)
            {
                return -1;
            }
            int start = 0;
            int end = array.length - 1;
            int middle;
            while(start+1 < end)
            {
                //middle 随着start、end 变化而变化
				middle = start+(end - start) / 2;
                if(value == array[middle])
                {
                    return middle;
                }
                
                //确定升序，还是降序
                if(array[middle] > array[start])//升序
                {
                    //在start 和 middle
                    if(value <= array[middle] && value>=array[start])
                    {
                        end = middle;
                    }else
                    {
                        start = middle;
                    }
                }
                else
                {
                	if(value >=array[middle] && value <=array[end])
                    {
                        start = middle;
                    }    
                    else
                    {
                        end =middle;
                    }
                }
                
            }
            if(value==array[start])
            {
                return start;
            }
            if(value==array[end])
            {
                return end;
            }
            return -1;
        }
        public static void main(String[] args)
        {
            int[] a = { 7, 8, 9,1, 2, 3, 4, 5, 6};
            int value = binary(a, 9);
            System.out.println(value);
        }
    }

```

#### 1.3 在旋转有序数组中最小值  (无重复数组)

```java
class Solution {
   public int findMin(int[] nums) {
        if (nums == null || nums.length == 0) {
            return 0;
        }
        int start = 0;
        int end = nums.length - 1;
        int mid;
       while (start + 1 < end ) {
           mid = start + (end - start) / 2;           
           //正序
           if (nums[mid] >= nums[start]) {
               if (nums[end] <= nums[mid]) {
                   start = mid;
               } else {
                   end = mid;
               }
           } else {
               //end =mid;  ??
                start = mid; 
           }
       }
       return Math.min(nums[start], nums[end]);
    }
}
```

#### 1.4 [找峰值元素](https://leetcode-cn.com/problems/find-peak-element/)

```java
class solution1{
    public int findPeakElement(int[] nums)
    {
        if(nums == null || nums.length==0)
        {
            return -1;
        }
        int start = 0;
        int end = nums.length -1;
        int mid;
        while(start+1 < end)
        {
            mid = start + (end-start)/2;
            if(nums[mid]<nums[mid-1])
            {
				end= mid;
            }
            else if(nums[mid]<nums[mid+1])
            {
                start = mid;
            }
            else
            {
                return mid;
            }
        }
        return nums[start]>nums[end] ? start:end;        
    }
    
}

```



### 2.[快速排序]([https://baike.baidu.com/item/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95?fromtitle=%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F&fromid=2084344#4_10](https://baike.baidu.com/item/快速排序算法?fromtitle=快速排序&fromid=2084344#4_10))

```python
D&C 分而治之的思想，欧几里德算法（辗转相除法）   递归的思想

基线条件：数组为空或者只有一个元素时  （类似与初中时给函数并找规律）

实例：农场主分地问题  1680 X 640 --> 640 X 400 --> 240 X 400 --> 240 X 160 --> ..

def quick_sort(data):
    """快速排序"""
    length = len(data)
    # print(length//2)
    if length >= 2:  # 递归入口及出口
        mid = data[length // 2]  # 选取基准值，也可以选取第一个或最后一个元素
        print(mid)
        left, right = [], []  # 定义基准值左右两侧的列表
        data.remove(mid)  # 从原始数组中移除基准值
        for num in data:
            if num >= mid:
                right.append(num)
            else:
                left.append(num)
        return quick_sort(left) + [mid] + quick_sort(right)
    else:
        return data

if __name__ == '__main__':
    # 示例：
    array = [2, 3, 5, 7, 1, 4, 6, 15, 5, 2, 7, 9, 10, 15, 9, 17, 12]
    print(quick_sort(array))
    # 输出为[1, 2, 2, 3, 4, 5, 5, 6, 7, 7, 9, 9, 10, 12, 15, 15, 17]
```

### 3.[合并排序](https://baike.baidu.com/item/%E5%90%88%E5%B9%B6%E6%8E%92%E5%BA%8F/2669171?fr=aladdin)

```
将两个（或两个以上）有序表合并成一个新的有序表，即把待排序序列分为若干个子序列，每个子序列是有序的。然后再把有序子序列合并为整体有序序列。
```

```java
public static void mergeSort(int[]array){

  int length=array.length;
  int middle=length/2;

  if(length>1){
    int[]left=Arrays.copyOfRange(array,0,middle);//拷贝数组array的左半部分
    int[]right=Arrays.copyOfRange(array,middle,length);//拷贝数组array的右半部分
    mergeSort(left);//递归array的左半部分
    mergeSort(right);//递归array的右半部分
    merge(array,left,right);//数组左半部分、右半部分合并到Array
  }
}

//合并数组，升序
private static void merge(int[]result,int[]left,int[]right){

  int i=0,l=0,r=0;

  while(l<left.length&&r<right.length){
    if(left[l]<right[r]){
      result[i]=left[l];
      i++;
      l++;
    }else{
      result[i]=right[r];
      i++;
      r++;
   }
  }

  while(r<right.length){//如果右边剩下合并右边的
    result[i]=right[r];
    r++;
    i++;
  }

  while(l<left.length){
    result[i]=left[l];
    l++;
    i++;
  }
}
```

### 4.[深度优先搜索](https://www.jianshu.com/p/bff70b786bb6)

​	树（由上到下） ---> 栈结构遍历

### 5.广度优先搜索

```
用图的查找算法，主要解决两类问题：

  <1.从节点A出发，有前往节点B的路径吗？
  <2.从节点A出发，前往节点B的哪条路径最短？（段数/边最少的路径）
```

实例：在人际圈中查找水果经销商 --你的人际圈（一度关系）、你朋友的人际圈（二度关系）、朋友的朋友的人际圈（三度关系）

### 6.狄克斯特拉

    找出最快到达目的地的路径。（所用时间最少的路径）
    
    区别广度优先搜索：找出段数最少的路径（尽量少转车而达到目的地的路径）
    
    狄克斯特拉算法用于每条边都有关联数字的图，这些数字称为权重（weight）。
    
    带权重的图称为加权图（weighted graph），不带权重的图称为非加权图（unweighted graph）。


    **负权边** 时，该算法不使用，可采用[贝尔曼-福德算法（Bellman-Fordalgorithm）]
    
    实例： 换钢琴
    
    总结：
    
      要计算非加权图中的最短路径，可使用广度优先搜索。
      要计算加权图中的最短路径，可使用狄克斯特拉算法(只适应有向无环图)。

### 7.贪婪算法

    选择每个最优，则全最优。（排课表、背包问题、集合覆盖问题、近似完全问题）   近似算法（NP完全问题）
    
    这是一种近似最优的算法（背包问题：最多拿10千克重的物品，请选择价值最大的。 10kg 6000元的音响、4kg 5000元的笔记本电脑、6kg 2000元的手提琴，通过贪婪算法，结果会选出10kg 6000元的音响，而 后面两者之后大于6000元的音响的价值。）

### 8.动态规划

```
将问题分成各个小问题，先解决小问题，再逐步解决大问题。
（背包问题、最长公共子串）
```

### 9.[K最近邻算法]([https://baike.baidu.com/item/k%E8%BF%91%E9%82%BB%E7%AE%97%E6%B3%95/9512781](https://baike.baidu.com/item/k近邻算法/9512781))

```
1.创建推荐系统（特征抽取、回归<期望值>、挑选合适的特征)
2.机器学习（OCR<图像识别文字>、创建垃圾邮件过滤器<贝叶斯分类器>、股票市场预测<影响因数多>)
```



### 10.总结/扩展

```
1.二叉树
2.反向索引
3.傅里叶变换（分类、DNA分析、音乐识别）
4.并行计算
5.MapReduce
	<1.分布式算法
	<2.映射函数
	<3.归并函数
6.布隆过滤器和HyperLogLog
7.SHA算法
8.局部敏感的散列算法
9.Diffie-Hellman密钥交换
10.线性规划
```





### 参考

<<算法图解>>

- ”程序员小灰“ 公众号 (推荐)

[合并排序](https://baike.baidu.com/item/%E5%90%88%E5%B9%B6%E6%8E%92%E5%BA%8F/2669171?fr=aladdin)

[贝尔曼-福德算法（Bellman-Fordalgorithm）](https://baike.baidu.com/item/Bellman-Ford%E7%AE%97%E6%B3%95/1089090?fr=aladdin)

[算法示例](https://github.com/egonSchiele/grokking_algorithms)

[二分法查找-百度百科]([https://baike.baidu.com/item/%E4%BA%8C%E5%88%86%E6%B3%95%E6%9F%A5%E6%89%BE/9751511?fr=aladdin#3](https://baike.baidu.com/item/二分法查找/9751511?fr=aladdin#3))

[快速排序-百度百科]([https://baike.baidu.com/item/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95?fromtitle=%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F&fromid=2084344#4_10](https://baike.baidu.com/item/快速排序算法?fromtitle=快速排序&fromid=2084344#4_10))

[K最近邻算法]([https://baike.baidu.com/item/k%E8%BF%91%E9%82%BB%E7%AE%97%E6%B3%95/9512781](https://baike.baidu.com/item/k近邻算法/9512781))

[深度/广度优先搜索](https://www.jianshu.com/p/bff70b786bb6)

