---
layout: post
title: "设计模式概述"
date: 2018-03-04
categories: 设计模式
tags: 设计模式 面向对象设计原则
---

* content
{:toc}

常用设计模式概述

## 一、设计模式

​	定义：总结前人的经验，去借鉴（来源于生活，总结经验，并运用于生活）

​	目的：提升代码可读性、扩展性、降低维护成本（具体的业务使用具体的设计模式，不可盲目套用）



## 二、面向对象设计原则

```
	单一职责：控制变量法

	开闭原则：对扩展开放，对修改关闭（使用接口和抽象类）

	里式代换原则：程序中使用基类定义对象，运行时确定子类类型，用子类替换基类类型 （“开-闭”补充）

	依赖倒转：抽象不依赖细节，细节依赖抽象 [接口编程]

	接口隔离：使用多个专门接口，不使用单一总接口(有选择的依赖接口/抽象)

	合成复用：尽量使用合成/聚合的方式，而不使用继承

	迪米特法则：一个软件/抽象应尽可能少的与其他实体发生相互作用（降低耦合）

```


## 三、设计模式分类

​	创建型、结构型、行为型


### 1.创建型模式 

```

   	（1）简单工厂模式(Simple Factory Pattern)：定义一个工厂类，它可以根据参数的不同返回不同的实例，被创建的实例通常都具有共同的父类。因为在简单工厂模式中创建实例的方法是静态的（static),因此简单工厂又被称为静态工厂方法。（不属于设计模式，如果有很多实现类或新引入实现类时，很麻烦，需改源码，违反了“开闭”原则）

   	（2）工厂方法模式（Factory Method Pattern):定义一个用户创建对象的接口，让子类决定将哪一个类实例化。工厂方法模式让一个类的实例化延迟到子类（里式代换原则、依赖倒转）  多态工厂模式  <创建既定的,可通过读取配置文件扩展>

	（3）抽象工厂模式（Abstract Factory Pattern):提供一个创建一系列相关或相互依赖对象的接口，而不需指定他们的具体的类。（Kit模式）-皮肤库换肤<多个抽象工厂>

 	（4）单例模式（Singleton Pattern) :确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例，这个类称为单例，它提供全局访问的方法。（Spring 默认使用单例模式实例化对象）

    （5）原型模式（Prototype Pattern)：使用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。（标签）

 	（6）建造者模式（Builder Pattern):讲一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。
```


### 2.结构类型模式

```

   	 (1) 适配器模式（Adapter Pattern):将一个接口转换成客户需要的另一个接口，使接口不兼容的那些类可以一起工作，其别名为包装器（Wrapper）。  -- 双孔插座与三孔插座   类、对象、接口

	（2）桥接模式（Bridge Pattern):将抽象部分与它的实现部分分离，使它们可以独立的变化。（柄体Hanle and Body、接口Interface)模式 。  -- 不同的网段，通过桥接互联   

  	（3）组合模式（Composite Pattern):组合多个对象形成树形结构以表示具有“整体-部分”关系的层次结构。组合模式对单个对象和组合对象的使用具有一致性。  -- 树的节点

  	（4）装饰模式（Decorator Pattern）：动态地给一个对象增加一些额外的职责，就增加对象的功能而言，装饰模式比生成子类的实现更为灵活。 --可添加一些验证、日志等

	 (5)  外观模式（Facade Pattern):为子系统中的一组接口提供一个统一的入口。外观模式定义了一个高层接口，

这个接口使得这一子系统更加容易使用。（喝茶：自己在家煮茶喝、到茶馆去喝茶）

  	（6）享元模式（Flyweight Pattern):运用共享技术有效地把大量细颗粒度的对象复用，系统只是用少量的对象，而这些对象很相似，状态变化很小，可以实现对象的多次复用。  （轻量模式 -- 一盘围棋 位置拜访等）

  	（7）代理模式（Proxy Pattern):给某一个对象提供一个代理或占位符，并有代理对象来控制对原对象的访问。 -- 中介、代购、快捷键

```

### 3.行为模式

```
 	（1）职责链模式（Chain of Responsibility Pattern):避免请求发送者与接收者耦合在一起，让多个对象都有可能接收请求，将这些对象连接成一条链，并且沿着这条链条传递请求，直到有对象处理它为止。（Servlet 职责链模式)

 	（2）命令模式（Command Pattern）：将请求封装为一个对象，从而让我们可用不同的请求对客户进行参数化；对请求排队或记录请求日志，以及支持可撤销的操作。（动作Action模式或者事务Transaction模式） 长官下命令，士兵执行

	（3）解释器模式（Interpreter Pattern)：定义一个语言的文法，并建立一个个解释器来解释该语言中的句子，这里的语言是指使用规定格式和语法代码。 --计算器

   	 (4）迭代器模式（Iterator Pattern):提供一种方法来访问聚合对象，而不用暴露这个对象的内部表示，其别名为游标（Cursor） -- 集合遍历时 Iterator

	 (5) 中介模式（Mediator Pattern):用一个中介对象（中介者）来封装一系列的对象交互，中介者使各对象不需要显示地相互引用，从而时期耦合度松散，而且可以独立的改变它们之间的交互。又称调停模式（协调多个对象间的交互）

  	（6）备忘录模式（Memento Pattern):在不破坏封装的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，这样可以在以后将对象恢复到原先保存的状态。（撤销功能 --存库，每个版本的状态）

  	（7）观察者模式（Observer Pattern):定义对象间的一种一对多依赖关系，使得每当一个对象状态发生变化时，其相关依赖对象皆得到通知冰杯自动更新。（对象间的联动-RSS订阅）观察者的别名包括发布-订阅（Publish/Subscribe)模式、模型-视图（Model/View)模式、源-监听器（Source/Listener)模式或从属者（Dependents)模式。

	（8）状态模式（State Pattern）允许一个对象在其内部状态改变时改变它的行为，对象看起来修改了它的类。其别名为状态对象（Objects for States)  --(处理对象的多种状态及其相互转换) 银行用户状态转换问题 大于取款金额

	（9）策略模式（Strategy Pattern)定义一个算法类，将每一个算法封装起来，并让它们可以相互替换，策略模式让算法独立于使用它的客户而变化。（算法的封装与切换 --->存款 一般用户、VIP用户）

 	 (10) 模板方法模式（Template Method Pattern) 定义一个操作中算法的框架，而降一些步骤延迟到子类中。模板方法模式使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。（银行利息模板）

	（11）访问者模式（Visitor Pattern) 提供一个作用于某对象结构中的各个元素的操作表示，它使我们可以在不改变各个元素的类的前提下定义作用于这些元素的新操作。（新增访问者符合开闭原则，新增新元素不符合开闭原则）

```



## 四、常用设计模式与编程思想的总结

| 设计模式              | 一句话归纳                                                   |
| --------------------- | ------------------------------------------------------------ |
| 工厂模式(Factory)     | 只对结果负责,不要三无产品。                                  |
| 单例模式(Singleton)   | 保证独一无二。                                               |
| 适配器模式(Adapter)   | 需要一个转换头(兼容)。<br/><font color='red'>主数据采集：定义采集接口,<br/>定义实现采集接口的抽象类，<br/>定义各种继承抽象类的采集类</font> |
| 装饰器模式(Decorator) | 需要包装,但不改变本质(同宗同源)。                            |
| 代理模式(Proxy)       | 办事要求人,所以找代理。<br/><font color='red'>微服务中服务间调用</font>、<br/>Thread (Runable 虚拟机执行/ 源码分析)、<br/>动态代理：JDK基于接口、CGLIB基于继承；<br/><font color='red'>代理类一般把代理对象作为入参，然后操作代理对象</font> |
| 观察者模式(Observer)  | 完成时通知我。<br/>MQ： 类似于订阅功能                       |
| 策略模式(Strategy)    | 我行我素,达到目的就行。<br/><font color='red'> 比如在客户单实现负载均衡策略算法时</font> [示例](https://gitee.com/xushj/DesinPatternLearn/tree/master/src/main/java/com/mzz/behavior/fatherandson/strategy) |
| 模板模式(Template)    | 流程标准化,原料自己加。<br/>[基于抽象类，定义不同模板](https://gitee.com/xushj/DesinPatternLearn/tree/master/src/main/java/com/mzz/behavior/fatherandson/template) |
| 委派模式(Delegate)    | 干活是你的(普通员工),功劳是我的(项目经理)。                  |
| 原型模式(Prototype)   | 拔一根猴毛,吹出千万个。<br/><font color='red'>浅拷贝、深拷贝</font> |
| 桥接模式（Builder)    | 连接在一起，组成一个对象 <br/>buildHead(); buildTail(); .... |

[示例：https://gitee.com/xushj/DesinPatternLearn.git](https://gitee.com/xushj/DesinPatternLearn.git)

```
参考：https://gof.quanke.name/
```

